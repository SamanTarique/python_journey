# ğŸ“Œ PEP, Lexing & Parsing, Virtual Environments, pyenv

---

## ğŸ”¹ PEP (Python Enhancement Proposal)

- **Definition**: Documents that describe new features, improvements, or conventions for Python.  
- **PEP 8** â†’ Style guide for Python code.

### PEP 8 Key Rules
- **Indentation**: 4 spaces per level (âŒ never tabs).  
- **Naming conventions**:  
  - Variables & functions â†’ `snake_case`  
  - Classes â†’ `PascalCase`  
  - Constants â†’ `UPPER_CASE`  
- **Spacing**:  
  - Around operators â†’ `a = b + c`  
  - No spaces inside parentheses â†’ `func(x, y)` âœ… not `func( x, y )`  
- **Docstring**: String literal as the **first statement** in a module, function, class, or package.  
- **Line length**:  
  - Code â†’ 79 chars  
  - Comments/docstrings â†’ 72 chars  

### Wrapping Long Lines
- **Preferred**: Implicit joins with `()` `[]` `{}`  
  ```python
  query = (
      "SELECT id, email, created_at "
      "FROM users "
      "WHERE is_active = 1 "
      "ORDER BY created_at DESC "
      "LIMIT 500"
  )
  ```

### Blank Lines
- 2 blank lines â†’ before/after top-level `def` / `class`  
- 1 blank line â†’ between class methods (sometimes none if very small/related)  
- Imports â†’ 3 groups separated by 1 blank line:  
  1. Standard library  
  2. Third-party packages  
  3. Local imports  

### Tools for Enforcement
- **Formatter**: `black` (default line length 88).  
- **Linter**: `ruff` (fast, enforces PEP 8 + more, can auto-fix).  
- **Import sorter**: `ruff` (or `isort`).  

---

## ğŸ”¹ Lexing & Parsing

### Lexing (Tokenization)
- Converts raw source code â†’ **tokens** (smallest meaningful units).  
- Examples of tokens:  
  - Keywords â†’ `if`, `for`, `def`  
  - Identifiers â†’ `x`, `my_list`  
  - Operators â†’ `+`, `=`, `*`  
  - Literals â†’ `10`, `"hello"`  
  - Punctuation â†’ `:`, `,`, `()`  

Example:  
```python
x = 10 + 20
```
Tokens:  
`IDENTIFIER(x), OPERATOR(=), NUMBER(10), OPERATOR(+), NUMBER(20)`

---

### Parsing (Syntactic Analysis)
- Takes tokens â†’ arranges according to grammar â†’ builds **AST** (Abstract Syntax Tree).  

Example AST for `x = 10 + 20`:
```
Assignment
 â”œâ”€â”€ Variable: x
 â””â”€â”€ Expression (+)
      â”œâ”€â”€ Number: 10
      â””â”€â”€ Number: 20
```

---

### Why Both?
- **Lexing** â†’ cleans text â†’ tokens.  
- **Parsing** â†’ arranges tokens into structure â†’ AST.  

### Flow of Execution
```
Source code (.py)
   â†“
Tokenizer + Parser
   â†“
Abstract Syntax Tree (AST)
   â†“
Compiler
   â†“
Bytecode (.pyc)
   â†“
Python Virtual Machine (PVM) executes
```

---

## ğŸ”¹ Virtual Environments

- A **self-contained Python setup** for a project.  
- Has:  
  - Its own **Python interpreter (binary)**.  
  - Its own **site-packages/** (installed libraries).  
- **Purpose**: Keep dependencies isolated per project (like `node_modules` in JS).  
- Benefit: Prevents global Python pollution & version conflicts.  

---

## ğŸ”¹ pyenv

- **Manages Python interpreters/versions**, not packages.  
- Example use:  
  - Install multiple versions: `3.9.20`, `3.10.15`, `3.11.9`  
  - Set:  
    - Global version â†’ default system-wide  
    - Local version â†’ per project (creates `.python-version` file)  

### Install & Setup
```bash
curl https://pyenv.run | bash
```
Add to `~/.bashrc` or `~/.zshrc`:
```bash
export PATH="$HOME/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
```
Reload shell.  

### Usage
```bash
# List available versions
pyenv install --list | grep " 3\."

# Install versions
pyenv install 3.10.14
pyenv install 3.12.5

# Set global version
pyenv global 3.12.5
python --version   # 3.12.5

# Set per-project version
cd ~/projects/myapp
pyenv local 3.10.14
python --version   # 3.10.14
```

---

## ğŸ”¹ Virtual Environment Creation (3 Common Ways)

1. **venv (built-in)**  
   ```bash
   python3 -m venv my_env
   source my_env/bin/activate
   ```

2. **virtualenv (external)**  
   ```bash
   pip install virtualenv
   virtualenv my_env
   ```

3. **conda (Anaconda/Miniconda)**  
   ```bash
   conda create --name my_env python=3.11
   conda activate my_env
   ```

---

## ğŸ”¹ Why Use Virtual Envs if pyenv Exists?

- **pyenv** â†’ answers *which Python binary/version to run*.  
- **virtualenv/venv/conda** â†’ answers *which packages & versions are installed*.  

Example conflict:  
- Project A â†’ Django 4.2  
- Project B â†’ Django 5.0  

ğŸ‘‰ Even with the same Python version, virtual envs isolate packages so they donâ€™t clash.